---
import type { ComponentProps } from "astro/types";
import { getAspectClass } from "src/utils";

interface Props {
  youTubeInfo?: { id: string; aspect: "16/9" | "16/10" };
  color?: YT.ProgressBarColor;
  autoplay?: boolean;
  mute?: boolean;
  loop?: boolean;
  className?: string;
  trackTime?: boolean;
}

const {
  youTubeInfo: { id, aspect } = {
    id: "",
    aspect: "16/9",
  } satisfies ComponentProps<typeof Video>["youTubeInfo"],
  color = "white",
  autoplay = true,
  mute = true,
  loop = true,
  className = "",
  trackTime,
} = Astro.props;

const noControls = className.includes("pointer-events-none");

const boolToInt = (value?: boolean) => (value ? 1 : 0);

import "node_modules/lite-youtube-embed/src/lite-yt-embed.css";
---

<div
  class={`size-full overflow-hidden flex items-center justify-center ${getAspectClass(aspect)}`}
>
  <div class="size-full">
    <lite-youtube
      js-api
      videoid={id}
      params={`playlist=${id}&color=${color}&autoplay=${boolToInt(autoplay)}&mute=${boolToInt(mute)}&loop=${boolToInt(loop)}&controls=${boolToInt(!noControls)}&disablekb=${boolToInt(noControls)}`}
      class={`${className} size-full`}
      data-aspect-ratio={aspect}
      {...trackTime ? { "data-current-time": 0 } : {}}></lite-youtube>
    <style>
      /* Fix default styles */
      lite-youtube {
        max-width: none;
      }
    </style>
  </div>
  <script src="node_modules/lite-youtube-embed/src/lite-yt-embed.js"></script>
  <script>
    import type { LiteYTEmbed } from "lite-youtube-embed";
    import { getAspectRatio, switchClasses } from "src/utils";

    const getVideos = () => document.querySelectorAll("lite-youtube");

    let currentTimeInterval: NodeJS.Timeout | undefined;

    const setCurrentTime = (element: HTMLElement, seconds: number) =>
      (element.dataset.currentTime = seconds.toFixed());

    const setCurrentTimes = async () => {
      const videos = getVideos();

      if (!videos.length) {
        clearInterval(currentTimeInterval);
        currentTimeInterval = undefined;
        return;
      }

      for (const lyt of videos) {
        const player = await lyt.getYTPlayer();
        if (!player) continue;
        setCurrentTime(lyt, player.getCurrentTime());
      }
    };

    const isActivated = (lyt: Element) =>
      lyt.classList.contains("lyt-activated");

    document.addEventListener("astro:page-load", () => {
      // Auto resize for object-cover videos
      const containerObserver = new ResizeObserver((entries) =>
        entries.forEach(({ target }) => {
          if (!target.checkVisibility()) return;

          const resizingDiv = target.firstElementChild! as HTMLDivElement;
          const lyt = resizingDiv.firstElementChild! as LiteYTEmbed;

          const containerIsWider =
            target.clientWidth / target.clientHeight >
            getAspectRatio(lyt.dataset.aspectRatio!);
          // Resize width if container is wider, else height
          switchClasses(resizingDiv, containerIsWider, ["h-auto"], ["w-auto"]);
          // Expand width if container is wider, else height
          switchClasses(
            lyt,
            containerIsWider,
            ["h-[300dvw]", "w-full"],
            ["h-full", "w-[300dvh]"]
          );
        })
      );

      // Handle lite youtube embeds
      const lytObserver = new IntersectionObserver((entries) => {
        entries.forEach(async ({ target, isIntersecting }) => {
          const lyt = target as LiteYTEmbed;

          // Play or pause player
          if (isIntersecting) {
            // Should initialize
            if (!isActivated(lyt)) {
              const videoId = lyt.getAttribute("videoid")!;

              // Set start time
              const start = Number(
                sessionStorage.getItem(`video/${videoId}`) ?? 0
              );
              setCurrentTime(lyt, start);

              lyt.setAttribute(
                "params",
                `${lyt.getAttribute("params")}&start=${start}`
              );

              // Init time tracker
              if (lyt.dataset.currentTime) {
                currentTimeInterval ??= setInterval(setCurrentTimes, 1000);
              }
            }

            const player = await lyt.getYTPlayer();
            if (!player) return;
            player.playVideo();
          } else {
            if (!isActivated(lyt)) return;

            const player = await lyt.getYTPlayer();
            if (!player) return;
            player.pauseVideo();
          }
        });
      });

      getVideos().forEach((lyt) => {
        if (lyt.classList.contains("object-cover")) {
          // Remove black bands
          containerObserver.observe(lyt.parentElement!.parentElement!);
        }

        lytObserver.observe(lyt);
      });
    });

    //? Save times to restore start times
    const savePlayerTimes = async () => {
      const videoData = Object.groupBy(
        getVideos(),
        (video) => video.getAttribute("videoid")!
      );

      // Save longest time watched for each video ID
      for (const videoId in videoData) {
        const players = await Promise.all(
          videoData[videoId]!.map((lyt) => lyt.getYTPlayer())
        );

        players.sort(
          (playerA, playerB) =>
            (playerB?.getCurrentTime() ?? 0) - (playerA?.getCurrentTime() ?? 0)
        );

        sessionStorage.setItem(
          `video/${videoId}`,
          players[0]!.getCurrentTime().toFixed()
        );
      }
    };

    document.addEventListener("astro:before-swap", savePlayerTimes);
    addEventListener("beforeunload", savePlayerTimes);
  </script>
</div>
