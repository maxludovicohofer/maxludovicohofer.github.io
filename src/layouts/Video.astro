---
import type { ComponentProps } from "astro/types";

interface Props {
  youTubeInfo?: { id: string; aspect: "16/9" | "16/10" };
  color?: YT.ProgressBarColor;
  autoplay?: boolean;
  mute?: boolean;
  loop?: boolean;
  className?: string;
  trackTime?: boolean;
}

const {
  youTubeInfo: { id, aspect } = {
    id: "",
    aspect: "16/9",
  } satisfies ComponentProps<typeof Video>["youTubeInfo"],
  color = "white",
  autoplay = true,
  mute = true,
  loop = true,
  className = "",
  trackTime,
} = Astro.props;

// TODO FIX WEIRD SCROLLING ISSUES ON MOBILE

const noControls = className.includes("pointer-events-none");
const aspectClass = aspect === "16/10" ? "aspect-[16/10]" : "aspect-video";

const boolToInt = (value?: boolean) => (value ? 1 : 0);

import "node_modules/lite-youtube-embed/src/lite-yt-embed.css";
---

<div
  class={`size-full overflow-hidden flex items-center justify-center ${aspectClass}`}
>
  <div class="size-full">
    <lite-youtube
      js-api
      videoid={id}
      params={`playlist=${id}&color=${color}&autoplay=${boolToInt(autoplay)}&mute=${boolToInt(mute)}&loop=${boolToInt(loop)}&controls=${boolToInt(!noControls)}&disablekb=${boolToInt(noControls)}`}
      class={`${className} size-full ${aspectClass} ${trackTime ? "current-time-0" : ""} max-w-none`}
    ></lite-youtube>
  </div>
  <script src="node_modules/lite-youtube-embed/src/lite-yt-embed.js"></script>
  <script>
    import type { LiteYTEmbed } from "lite-youtube-embed";
    import { getTailwindValue, switchClasses } from "src/utils";

    const getVideos = () => document.querySelectorAll("lite-youtube");

    let currentTimeInterval: NodeJS.Timeout | undefined;
    const currentTimeRegex = /current-time-\d+/;

    const setCurrentTime = (element: Element, seconds: number) =>
      (element.className = element.className.replace(
        currentTimeRegex,
        `current-time-${seconds.toFixed()}`
      ));

    const setCurrentTimes = async () => {
      const videos = getVideos();

      if (!videos.length) {
        clearInterval(currentTimeInterval);
        currentTimeInterval = undefined;
        return;
      }

      for (const lyt of videos) {
        setCurrentTime(lyt, (await lyt.getYTPlayer()).getCurrentTime());
      }
    };

    const isActivated = (lyt: Element) =>
      lyt.classList.contains("lyt-activated");

    document.addEventListener("astro:page-load", () => {
      // Auto resize for object-cover videos
      const containerObserver = new ResizeObserver((entries) =>
        entries.forEach(({ target }) => {
          const containerAspectRatio = target.clientWidth / target.clientHeight;
          const videoAspectEnum = getTailwindValue(target, "aspect");
          const videoAspectRatio =
            videoAspectEnum === "16/10" ? 16 / 10 : 16 / 9;
          const containerIsWider = containerAspectRatio > videoAspectRatio;
          const resizingDiv = target.firstElementChild! as HTMLDivElement;

          // Resize width if container is wider, else height
          switchClasses(resizingDiv, containerIsWider, ["h-auto"], ["w-auto"]);
          // Expand width if container is wider, else height
          switchClasses(
            resizingDiv.firstElementChild!,
            containerIsWider,
            ["h-[300dvw]", "w-full"],
            ["h-full", "w-[300dvh]"]
          );
        })
      );

      // Handle lite youtube embeds
      const lytObserver = new IntersectionObserver((entries) => {
        entries.forEach(async ({ target, isIntersecting }) => {
          const lyt = target as LiteYTEmbed;

          // Play or pause player
          if (isIntersecting) {
            // Should initialize
            if (!isActivated(lyt)) {
              const videoId = lyt.getAttribute("videoid")!;

              // Set start time
              const start = Number(
                sessionStorage.getItem(`video/${videoId}`) ?? 0
              );
              setCurrentTime(lyt, start);

              lyt.setAttribute(
                "params",
                `${lyt.getAttribute("params")}&start=${start}`
              );

              // Init time tracker
              if (lyt.className.match(currentTimeRegex)) {
                currentTimeInterval ??= setInterval(setCurrentTimes, 1000);
              }
            }

            (await lyt.getYTPlayer()).playVideo();
          } else {
            if (!isActivated(lyt)) return;

            (await lyt.getYTPlayer()).pauseVideo();
          }
        });
      });

      getVideos().forEach((lyt) => {
        if (lyt.classList.contains("object-cover")) {
          // Remove black bands
          containerObserver.observe(lyt.parentElement!.parentElement!);
        }

        lytObserver.observe(lyt);
      });

      // TODO RESTART VIDEOS ON FOCUS REGAINED IF OBJECT COVER
      // onfocus = () => lytObserver;
    });

    //? Save times to restore start times
    const savePlayerTimes = async () => {
      const videoData = Object.groupBy(
        getVideos(),
        (video) => video.getAttribute("videoid")!
      );

      // Save longest time watched for each video ID
      for (const videoId in videoData) {
        const players = await Promise.all(
          videoData[videoId]!.map((lyt) => lyt.getYTPlayer())
        );

        players.sort(
          (playerA, playerB) =>
            playerB.getCurrentTime() - playerA.getCurrentTime()
        );

        sessionStorage.setItem(
          `video/${videoId}`,
          players[0]!.getCurrentTime().toFixed()
        );
      }
    };

    document.addEventListener("astro:before-swap", savePlayerTimes);
    addEventListener("beforeunload", savePlayerTimes);
  </script>
</div>
