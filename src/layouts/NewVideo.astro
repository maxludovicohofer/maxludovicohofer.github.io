---
import type { ComponentProps } from "astro/types";

interface Props {
  youTubeInfo?: { id: string; aspect: "16/9" | "16/10" };
  color?: YT.ProgressBarColor;
  autoplay?: boolean;
  mute?: boolean;
  loop?: boolean;
  className?: string;
  trackTime?: boolean;
}

// TODO PHASE 2 USE A LIGHTWEIGHT NPM PACKAGE TO EMBED IFRAME

const {
  youTubeInfo: { id, aspect } = {
    id: "",
    aspect: "16/9",
  } satisfies ComponentProps<typeof NewVideo>["youTubeInfo"],
  color = "white",
  autoplay = true,
  mute = true,
  loop = true,
  className = "",
  trackTime,
} = Astro.props;

const noControls = className.includes("pointer-events-none");
const aspectClass = aspect === "16/10" ? "aspect-[16/10]" : "aspect-video";

const boolToInt = (value?: boolean) => (value ? 1 : 0);
---

<link
  rel="stylesheet"
  href="node_modules/lite-youtube-embed/src/lite-yt-embed.css"
/><div
  class={`size-full overflow-hidden flex items-center justify-center ${aspectClass}`}
>
  <div class="size-full">
    <lite-youtube
      js-api
      videoid={id}
      params={`playlist=${id}&color=${color}&autoplay=${boolToInt(autoplay)}&mute=${boolToInt(mute)}&loop=${boolToInt(loop)}&controls=${boolToInt(!noControls)}&disablekb=${boolToInt(noControls)}`}
      class={`${className} size-full max-w-none ${aspectClass} ${trackTime ? "current-time-0" : ""}`}
    >
      <a
        href={`https://youtube.com/watch?v=${id}`}
        class="lyt-playbtn"
        title="Play Video"
      >
        <span class="lyt-visually-hidden">Play Video</span>
      </a>
    </lite-youtube>
  </div>
  <script src="node_modules/lite-youtube-embed/src/lite-yt-embed.js"></script>
  <script>
    import type { LiteYTEmbed } from "lite-youtube-embed";
    // import { getCssValue } from "src/utils";

    const getVideos = () => document.querySelectorAll("lite-youtube");

    let currentTimeInterval: NodeJS.Timeout | undefined;
    const currentTimeRegex = /current-time-\d+/;

    const setCurrentTime = (element: Element, seconds: number) =>
      (element.className = element.className.replace(
        currentTimeRegex,
        `current-time-${seconds.toFixed()}`
      ));

    const setCurrentTimes = async () => {
      const videos = getVideos();

      if (!videos.length) {
        clearInterval(currentTimeInterval);
        currentTimeInterval = undefined;
        return;
      }

      for (const lyt of videos) {
        setCurrentTime(lyt, (await lyt.getYTPlayer()).getCurrentTime());
      }
    };

    const isActivated = (lyt: Element) =>
      lyt.classList.contains("lyt-activated");

    document.addEventListener("astro:page-load", () => {
      //? Init divs for iframe and resize dynamically
      // const containerObserver = new ResizeObserver((entries) =>
      //   entries.forEach(({ target }) => {
      //     const containerAspectRatio = target.clientWidth / target.clientHeight;
      //     const videoAspectEnum = getCssValue(target, "aspect");
      //     const videoAspectRatio =
      //       videoAspectEnum === "16/10" ? 16 / 10 : 16 / 9;
      //     const containerIsWider = containerAspectRatio > videoAspectRatio;

      //     const resizingDiv = target.firstElementChild! as HTMLDivElement;

      //     const resizeWidth = ["h-auto"];
      //     const resizeHeight = ["w-auto"];
      //     resizingDiv.classList.remove(...resizeWidth, ...resizeHeight);
      //     resizingDiv.classList.add(
      //       ...(containerIsWider ? resizeWidth : resizeHeight)
      //     );

      //     const iFrame = resizingDiv.firstElementChild! as HTMLIFrameElement;

      //     const expandWidth = ["h-[300dvw]", "w-full"];
      //     const expandHeight = ["h-full", "w-[300dvh]"];
      //     iFrame.classList.remove(...expandWidth, ...expandHeight);
      //     iFrame.classList.add(
      //       ...(containerIsWider ? expandWidth : expandHeight)
      //     );
      //   })
      // );

      // document
      //   .querySelectorAll<HTMLDivElement>("div[class^=yt-player]")
      //   .forEach((div, key) => {
      //     // Assign unique IDs
      //     div.id = `${div.id}/${key}`;

      //     // Remove black bands
      //     if (!div.classList.contains("object-cover")) return;
      //     containerObserver.observe(div.parentElement!.parentElement!);
      //   });

      // Handle lite youtube embeds
      const lytObserver = new IntersectionObserver((entries) => {
        entries.forEach(async ({ target, isIntersecting }) => {
          const lyt = target as LiteYTEmbed;

          // Play or pause player
          if (isIntersecting) {
            // Should initialize
            if (!isActivated(lyt)) {
              const videoId = lyt.getAttribute("videoid")!;

              // Set start time
              const start = Number(
                sessionStorage.getItem(`video/${videoId}`) ?? 0
              );
              setCurrentTime(lyt, start);

              lyt.setAttribute(
                "params",
                `${lyt.getAttribute("params")}&start=${start}`
              );

              // Init time tracker
              if (lyt.className.match(currentTimeRegex)) {
                currentTimeInterval ??= setInterval(setCurrentTimes, 1000);
              }
            }

            (await lyt.getYTPlayer()).playVideo();
          } else {
            if (!isActivated(lyt)) return;

            (await lyt.getYTPlayer()).pauseVideo();
          }
        });
      });

      getVideos().forEach((lyt) => lytObserver.observe(lyt));
    });

    //? Save times to restore start times
    const savePlayerTimes = async () => {
      const videoData = Object.groupBy(
        getVideos(),
        (video) => video.getAttribute("videoid")!
      );

      // Save longest time watched for each video ID
      for (const videoId in videoData) {
        const players = await Promise.all(
          videoData[videoId]!.map((lyt) => lyt.getYTPlayer())
        );

        players.sort(
          (playerA, playerB) =>
            playerB.getCurrentTime() - playerA.getCurrentTime()
        );

        sessionStorage.setItem(
          `video/${videoId}`,
          players[0]!.getCurrentTime().toFixed()
        );
      }
    };

    document.addEventListener("astro:before-swap", savePlayerTimes);
    addEventListener("beforeunload", savePlayerTimes);
  </script>
</div>
